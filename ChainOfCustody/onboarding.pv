(* ECDH *)
type G.
type exponent.

const g: G [data].
fun exp(G, exponent): G.
equation forall x: exponent, y: exponent; exp(exp(g, x), y) = exp(exp(g, y), x).

(* Symmetric key encryption *)
type key.
fun senc(bitstring, G): bitstring.
reduc forall m: bitstring, k: G; sdec(senc(m, k), k) = m.

(* Function to encrypt a key with a key *)
fun senc_key(key, G): bitstring.
reduc forall k1: key, k2: G; sdec_key(senc_key(k1, k2), k2) = k1.

(* Asymmetric key encryption *)
type skey.
type pkey.

fun pk(skey): pkey.
fun aenc(bitstring, pkey): bitstring.

reduc forall m: bitstring, sk: skey; adec(aenc(m, pk(sk)), sk) = m.

(* Digital signatures *)
type sskey.
type spkey.

fun spk(sskey): spkey.
fun sign(bitstring, sskey): bitstring.

reduc forall m: bitstring, ssk: sskey; getmess(sign(m, ssk)) = m.
reduc forall m: bitstring, ssk: sskey; checksign(sign(m, ssk), spk(ssk)) = m.



(* Hash function *)
fun h(bitstring): bitstring.

(* Key derivation function *)
fun f(bitstring): key.

(* Function to concatenate two keys *)
fun concat_key(key, key): bitstring.
(* Function to concatenate two bitstring *)
fun concat(bitstring, bitstring): bitstring.

(* Definition of variables *)
free w_D: bitstring [private].               (* IoT device password *)
free N_D: bitstring [private].               (* IoT device serial number *)
free B_D: bitstring [private].               (* Bluetooth MAC address of the IoT device *)

(* Definizione dei canali *)
free c: channel [private].                   (* Channel between SmartApp and SUP (TLS) *)
free c1: channel [private].                  (* Channel between SUP and Gateway (TLS) *)
free c2: channel.                            (* Bluetooth channel between gateway and IoT device *)

(* Definition of events *)
event begin_auth_G(bitstring, bitstring). 
event end_auth_G(bitstring,bitstring).                   
event begin_auth_D(bitstring, bitstring).            
event end_auth_D(bitstring, bitstring).                   

event ev_key_D(key).
event ev_key_G(key).

(* Query *)
query attacker(w_D).
query attacker(N_D).
query attacker(B_D).


query challenge: bitstring, w_D:bitstring; event(end_auth_G(challenge,w_D)) ==> inj-event(begin_auth_D(challenge, w_D)).
query challenge: bitstring, w_D:bitstring; event(end_auth_D(challenge, w_D)) ==> inj-event(begin_auth_G(challenge, w_D)).

query k:key; event(ev_key_G(k)) ==> inj-event(ev_key_D(k)).   (* If the Gateway has the key, it is the one generated by the Device *)




(* Process definition *)
let SmartApp(e_G: pkey, N_D: bitstring, w_D: bitstring, B_D: bitstring) =
  (* 1. SmartApp encrypts (w_D, B_D) with e_G *)
  let M = aenc((w_D, B_D), e_G) in
  (* 2. SmartApp sends (M, N_D) to SUP *)
  out(c, (M, N_D));
  0.

let SUP(e_G: pkey) =
  (* 3. SUP receives (M, N_D) from SmartApp *)
  in(c, (M: bitstring, N_D: bitstring));
  (* 4. SUP sends M to Gateway *)
  out(c1, M);
  0.

let Gateway(e1_G: G, d1_G: exponent, e_G: pkey, d_G: skey) =
  (* 5. Gateway receives M from SUP *)
  in(c1, M: bitstring);
  (* 6. Gateway decrypts M with d_G to get (w_D, B_D) *)
  let (w_D: bitstring, B_D: bitstring) = adec(M, d_G) in
  (* 6.1 Gateway generates a random challenge *)
  new challenge: bitstring;
  event begin_auth_G(challenge, w_D);   (* Gateway authentication start *)
  (* 6.2 Gateway sends challenge to IoT device *)
  out(c2, challenge);
  (* 6.6 Gateway receives challenge response from IoT device *)
  in(c2, response: bitstring);
  (* 6.7 Gateway calculates expected response *)
  let expected_response = h(concat(challenge, w_D)) in
  (* 6.8 Gateway compares the expected response with the received response *)
  if response = expected_response then 
    (* 7. Gateway sends e1_G to IoT device *)
    event end_auth_D(challenge, w_D);       (* IoT Device concludes authentication *)
    out(c2, e1_G);
    (* 12. Gateway receives (e1_D, Enc_k) from the IoT device *)
    in(c2, (e1_D: G, Enc_k: bitstring));
    (* 13. Gateway calculates K = exp(e1_D, d1_G) *)
    let K = exp(e1_D, d1_G) in
    (* 14. Gateway decrypts Enc_k with K to get k (which I call z)*)
    let z = sdec_key(Enc_k, K) in
    (* 15. Gateway calculates W = f(w_D) *)
    let W = f(w_D) in
    (* 16. Gateway sends h(h(k || W)) to IoT device *)
    out(c2, h(h(concat_key(z, W))));
    (* 21. Gateway receives h(k | W) from the IoT device *)
    in(c2, h_k_W: bitstring);
    (* 22. Gateway calculates h(k || W) *)
    let h_k_W_ = h(concat_key(z, W)) in
    (* 23. Gateway compares h_k_W with h_k_W_ *)
    if h_k_W = h_k_W_ then
      (* 24. If the comparison is successful, the Gateway sends a request for knownData_D to the IoT device *)
      new request_knownData_D: bitstring;
      out(c2, senc(request_knownData_D, K));
      (* 28. Gateway receives encrypted knownData_D from the IoT device *)
      in(c2, Enc_knownData_D: bitstring);
      (* 29. Gateway decrypts Enc_knownData_D with K to obtain knownData_D *)
      let knownData_D: bitstring = sdec(Enc_knownData_D, K) in
  0.

let IoT_Device(e1_D:G, d1_D:exponent, w_D: bitstring, B_D: bitstring, N_D:bitstring) =
  (* 6.3 IoT device receives challenge from Gateway *)
  in(c2, challenge: bitstring);
  event begin_auth_D(challenge, w_D);       (* IoT Device starts authentication *)
  (* 6.4 IoT device calculates challenge response by hashing concatenated challenge and pwd*)
  let response = h(concat(challenge, w_D)) in
  (* 6.5. oT device sends response to Gateway *)
  out(c2, response);

  (* 8. IoT device receives e1_G from Gateway *)
  in(c2, e1_G: G);
  (* 9. IoT device calculates K = exp(e1_G, d1_D) *)
  let K = exp(e1_G, d1_D) in
  (* 10. IoT device generates k *)
  new k: key;
  event ev_key_D(k); (* The IoT device holds the key *)
  (* 11. IoT device encrypts k with K to obtain Enc_k *)
  let Enc_k = senc_key(k, K) in
  (* 12. IoT device sends (e1_D, Enc_k) to Gateway *)
  out(c2, (e1_D, Enc_k));
  (* 17. IoT device receives h(h(k || W)) from the Gateway *)
  in(c2, h_k_W: bitstring);
  (* 18. IoT device calculates h(h(k || W)) *)
  let h_k_W_ = h(h(concat_key(k, f(w_D)))) in
  (* 19. IoT device compares h(h(k || W)) with h(h(k || W)) *)
  if h_k_W = h_k_W_ then
    event ev_key_G(k); (* The Gateway has the key *)
    event end_auth_G(challenge,w_D);      (* End Gateway authentication *)
    (* 20. If the comparison is successful, the IoT device sends h(k || W) to the Gateway *)
    out(c2, h(concat_key(k, f(w_D))));
    (* 25. IoT device receives request for knownData_D from the Gateway *)
    in(c2, Enc_knownData_D: bitstring);
    (* 26. IoT device decrypts Enc_knownData_D with K to get knownData_D *)
    let requested_knownData_D: bitstring = sdec(Enc_knownData_D, K) in
    new knownData_D: bitstring;
    (* 27. IoT device sends encrypted knownData_D to the Gateway *)
    out(c2, senc(knownData_D, K));
    
  0.


(* Main process definition *)
process
  new d1_G: exponent;
  let e1_G = exp(g, d1_G) in
  new d_G: skey;
  let e_G = pk(d_G) in
  new d1_D: exponent;
  let e1_D = exp(g, d1_D) in
  (
    (!SmartApp(e_G, N_D, w_D, B_D))
    | (!SUP(e_G))
    | (!Gateway(e1_G, d1_G, e_G, d_G))
    | (!IoT_Device(e1_D, d1_D, w_D, B_D, N_D))
  )